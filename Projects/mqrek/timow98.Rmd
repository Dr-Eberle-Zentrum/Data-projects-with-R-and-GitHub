---
title: "timow98"
author: "Timo Walcher"
date: "`r Sys.Date()`"
output: md_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)

options(repos = c(CRAN = "https://cloud.r-project.org"))
if (!requireNamespace("pacman", quietly = TRUE)) {
  install.packages("pacman")} 
library(pacman)
p_load(tidyverse, cowplot)
```

## Data Manipulation Goals
1. Converting the ‘Date’ column to a proper date format to facilitate time-based analysis. 
  
Read the CSV file and display the head of the data. We can format the date column when importing the file.
```{r}
NVDA <- read_csv("NVDA_messedUp_final.csv", 
    col_types = cols(Date = col_date(format = "%Y-%m-%d"))) # Date format
head(NVDA)
```
2. Calculating weekly, monthly and yearly closing values from the dataset to identify trends and patterns in the stock performance over time.

Here we can use dplyr to get a new dataframe with the last Close value of every week, month and year.
```{r}
NVDA_monthly <- NVDA %>%
  mutate(Date_YM = format(Date, "%Y-%m")) %>%
  group_by(Date_YM) %>%
  summarise(monthly_close = last(Close))

NVDA_weekly <- NVDA %>%
  mutate(Date_YM = format(Date, "%Y-%W"),
         calendarweek = format(Date, "%W"),
         Date = format(Date, "%Y-%m-%d")) %>%
  group_by(Date_YM) %>%
  summarise(weekly_close = last(Close),
            calendarweek = first(calendarweek),
            Date = last(Date),
            weekly_open = first(Open))

# This part is right now unnecessary (explained below)
# NVDA_yearly <- NVDA %>%
#   mutate(year = format(Date, "%Y")) %>%
#   group_by(year) %>%
#   summarise(yearly_close = last(Close))

```
Now we have 3 new Dataframes.  
For the second Plot we need to extend the weekly dataframe. Right now, the left_join()-part is not neccessary, because I only needed this for the calculation of the performance, but I changed the calculation. I will keep it as comment until we're sure how to calculate the performance
```{r}
# Transform Date_YM column into datatype date 
 NVDA_weekly <- NVDA_weekly %>%
   mutate(Date_YMD = as.Date(paste0(Date_YM,"-01"), format = "%Y-%W-%d"),
          Date_YM = NULL)
# which somehow returns wrong week numbers

# Also add a column in NVDA_weekly with year so that we can join the yearly dataframe
NVDA_weekly <- NVDA_weekly %>%
   mutate(year = lubridate::year(Date_YMD))

# # Left join NVDA_weekly with NVDA_yearly
# NVDA_yearly$year <- as.double(NVDA_yearly$year)
# NVDA_merged <- left_join(NVDA_weekly, NVDA_yearly, by = "year")

# I did not do a join, so I will just write weekly into merged
NVDA_merged <- NVDA_weekly

# change datatypes (important for plot 2)
NVDA_merged$Date <- as.Date(NVDA_merged$Date)
NVDA_merged$calendarweek <- as.numeric(NVDA_merged$calendarweek)
```

Calculation of the performance (I have no Idea how). I asked ChatGPT how to calculate Stock Performance and implemented it accordingly.
```{r}
NVDA_merged <- NVDA_merged %>%
  mutate(
         percentage = ((weekly_close - weekly_open)/weekly_open)) %>%  
  drop_na()

```

## Visualisation: Plot 1
The closing values are now used to produce two charts
1. A plot with a logarithmic scale to highlight percentage changes over time.

First of all, the new dataframe with the column month is of type character. We need to change it back to the date format.
```{r}
NVDA_monthly$Date_YM <- as.Date(paste0(NVDA_monthly$Date_YM, "-01"))
```

When using logarithmic scales, NA values would create an error message, so first of all we need to do something about that. It would be possible to add just a tiny constant to all the NA values or just drop them. Adding a small constant would look like this:  
NVDA_monthly$mean_close_p <- NVDA_monthly$monthly_close + 1e-6  
But it would not be useful because there is only one NA value which is basically the recent month.
```{r}
NVDA_monthly <- NVDA_monthly %>% drop_na()
```

Now we can plot it. Here is a plot with a logarithmic scale.
```{r}
# This is for the labels on the x-axis
break_years <- as.Date(c("2000-01-01", "2010-01-01", "2020-01-01"))

p1 <- ggplot(NVDA_monthly, aes(x = Date_YM, y = monthly_close)) +
  geom_line(group = 1, color = "blue", linewidth = 1) +
  scale_y_log10(breaks = c(1, 10, 100, 1000), 
                label = \(tickposition) scales::comma(tickposition))+
  scale_x_date(breaks = break_years, labels = format(break_years, "%Y"), date_labels = "%Y") +
  labs(
    x = "Date",
    y = "Monthly values",
    title = "NVIDIA STOCK CHART - Logarithmic scale") +
  theme(panel.grid = element_line(colour = "lightgrey"),
        panel.background = element_rect(fill = "white"))
  
```

2. A plot with a linear scale to provide a clear representation of absolute stock values.
```{r}
# This is for the labels on the x-axis
break_years <- as.Date(c("2000-01-01", "2010-01-01", "2020-01-01"))

p2 <- ggplot(NVDA_monthly, aes(x = Date_YM, y = monthly_close)) +
  geom_line(group = 1, color = "black", linewidth = 1) +
  scale_y_continuous(breaks = c(0,200,400,600,800), limits = c(0,800))+
  scale_x_date(breaks = break_years, labels = format(break_years, "%Y"), date_labels = "%Y") +
  labs(
    x = "Date",
    y = "Monthly values",
    title = "NVIDIA STOCK CHART - Linear scale") +
  theme(panel.grid = element_line(colour = "lightgrey"),
        panel.background = element_rect(fill = "white"))
```
Now both plots next to each other
```{r plot_grid_output, fig.width=10, fig.height=5}
plot_grid(p1, p2, ncol = 2)
```

## Visualisation: Plot 2
```{r}
ggplot(NVDA_merged, aes(calendarweek, percentage, color = factor(year)))+
  geom_line(aes(group = year))+
  scale_x_continuous(breaks = c(0, 20, 40), labels = c(0,20,40))+
  guides(color = guide_legend(title = "Years"))+
  theme_minimal()+
  labs(
    x = "Week",
    y = "Average performance (%)",
    title = "Average weekly performance per year of Nvidia")

```
