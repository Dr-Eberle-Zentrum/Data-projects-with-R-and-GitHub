---
title: "Fomula One Solution"
author: "Nicolai Schwarz"
date: "2023-12-06"
output: html_document
runtime: shiny
---



```{r setup, include=FALSE}

# get this packages

source("install_packages.R")
library(shinyFiles)
library(shinyalert)
library(dplyr)
library(tidyr)

knitr::opts_chunk$set(echo = FALSE)
```

# This is my **Formula One Solution**

### Dear Jana,

after i first took a closer look in your provided `archive.zip`and sorted out the `.csv` tables of intrest.

My first thoughts been its just some selecting/deselecting and joining and go on with the visualization part.

Honestly i even tried to cheat and prepared the `.csv`s already with **OpenRefine** `r emo::ji("grin")` [Download Link](https://github.com/OpenRefine/OpenRefine/releases/download/3.7.6/openrefine-win-with-java-3.7.6.zip)

But by accident i imported the wrong `.csv` dats and already after trying to import the second `.csv` from your provided  [archive.zip](https://github.com/Dr-Eberle-Zentrum/Data-projects-with-R-and-GitHub/blob/main/Projects/JanaKimmich/archive.zip) folder, i came to this wunderful idea of creating this [**drop_n_slice_folder**](https://github.com/Dr-Eberle-Zentrum/Data-projects-with-R-and-GitHub/tree/Nicos_tryOut_branch/Jana_Formula_One/drop_n_slice_folder) for you ! `r emo::ji("grin")`


I  wasn't actuall sure if you wanna extend this project anytime to the other `.csv` dats aswell, but i should work with some minor adjustments.
  
          I didn't fully wrapped my head around already, mightbe snippets could be recycled, for the:
[**SOP-Issue**](https://github.com/Dr-Eberle-Zentrum/Data-projects-with-R-and-GitHub/blob/main/Projects/blubbi90/StandardOperatingProcedureLayout/project_description_v0.1.md)

***

I found it prettxy intresting and useful to see the **Top-10** Winners of diffrent years as well, so i used an [Interactive RMD Documents](http://rmarkdown.rstudio.com/authoring_shiny.html).
With the ***shiny package***',  you can embed Shiny inputs and outputs in your document. Outputs are automatically updated whenever inputs change.

(*If you wanna learn more about, click the* [*Link*](http://rmarkdown.rstudio.com/authoring_shiny.html))


***

So let us come back to this fantastic [**drop_n_slice_folder**](https://github.com/Dr-Eberle-Zentrum/Data-projects-with-R-and-GitHub/tree/Nicos_tryOut_branch/Jana_Formula_One/drop_n_slice_folder)  `r emo::ji("folder")` and let's have an closer look how it actuall works and helps to solve [your **Formula One Issue:**](https://github.com/Dr-Eberle-Zentrum/Data-projects-with-R-and-GitHub/blob/main/Projects/JanaKimmich/project-description.md)

***

##  The **Drop_n_slice_folder**

***
### So let us take a look inside the folder.
Therefor wer're using the [**shinyFiles packages**](https://github.com/thomasp85/shinyFiles)

***

```{r folder_content, echo=FALSE}

ui <- fluidPage(
  titlePanel("Here we can take a look into the Solution folder"),
  sidebarLayout(
    sidebarPanel(
      shinyFilesButton('files', 'Take a look into the folder', 'Upload', TRUE)
    ),
    mainPanel(
      tableOutput('filetable')
    )
  )
)


server <- function(input, output, session) {
  shinyFileChoose(input, 'files', roots = c(wd = '.'), filetypes = c('', 'txt', 'csv'))
  
  
  output$filetable <- renderTable({
    req(input$files)
  })
}


shinyApp(ui, server)




```

***

So you can see, we identified all `.csv`'s with the tables of interest,
  and pushed them together in **drop_n_slice folder**.
  
The rest of the .csv's is in the **commit_out folder**.
  They could easily added, if data inside is of intrest,
  and is related/connected in anyway within the `result.csv` (current by contain(column ID).)

***

### Now we need to import all these .csv tables into R, best at once

***

Therefor I wrote you an function ( `auto_import_csv` ), which do exactly that.


*You know im lazy* `r emo::ji("grin")`

But first:
```{r wd, echo=TRUE}
drop_path <- file.path(getwd(), "Solution/drop_n_slice")

# here we get the folder-path, once this should work with the selected shinyFiles folder input, but after a day couldn't figure out how ...
```

***

#### And *magic appear*, it pushes us all tables of intrest  in One big list of dataframes together , calling it 'once_in_all_together'

***

```{r import, echo=TRUE }

auto_import_csv <- function(file_path){
  
  file_list <- list.files(path = file_path, pattern = "\\.csv$", full.names = TRUE)        #-> here we could change the auto import to other data type's 
  data_frames <- list()
  
  for (file in file_list) {
    df_name <- tools::file_path_sans_ext(basename(file))  # uses filename as dataframe
    data_frames[[df_name]] <- read.csv(file)
  }
  
  return(data_frames)
}
once_in_all_together <- auto_import_csv(drop_path)

```

Let's take a look into the structure of:
 **once_in_all_together:**
 
***

```{r str_once_in_all, echo=FALSE}
str(once_in_all_together)

```

***

**Okay this big bastard is a way to fat and ugly, lets slice em down** of the columns of intrest.


***

### Therefor, you've probably already guessed, i created a function:

We'll call it the **big_slicer**

Now let's finish her job:

***

```{r big_slicer, echo=TRUE}

big_slicer <- function(on_tibble_list){
  tibble_list_intrest_col <- sapply(on_tibble_list, function(on_each_tibble){
    
    # might be better to store searching patter outside of the function 4 better edit control
    
    select_columns_of_intrest <- select(on_each_tibble, matches("^(result|race|driver|constructor)Id$"), contains("name"), matches("nationality"), matches("wins"), matches("year")) # matches("points"), matches("^positionOrder$"), matches("rank"
    return(select_columns_of_intrest)
    })
  return(tibble_list_intrest_col)
}

slice_it <- big_slicer(once_in_all_together)
```

***
I created a search list, but dunno the bang_bang_bang_operator is not willing to ** !!! bang** inside select-function !
`search_list <- list(
 matches("^(result|race|driver|constructor)Id$"),
  contains("name"),
  matches("nationality"),
  matches("wins"),
  matches("year")`

***

*kaquing* let's take a look what we got left in:\n
"**slice_it:**".

***

```{r str_slice_it, echo=FALSE}

str(slice_it)

```

***

***looks pretty dope ain't !?***

Okay, okay, there's still some fine tuning to be done...

...let's get this final surgery done manually.

***

```{r final_cut, echo=TRUE}
{
slice_it$races <- slice_it$races %>% # should work with map anyhow aswell
  select(-name)

slice_it$constructors <- slice_it$constructors %>%
  select(-nationality)

finally_all_sorted <- slice_it
}
```

***

And sort out the "names" in races and "nationality" in constructors

If we take a closer look at the structur of:


**finally_all_sorted:**

```{r str_finally_all_sorted, echo=FALSE}

str(finally_all_sorted)
```

***

We see, we only got the columns of interest left and those containing "Id".

Next we want to get all dataframe's (table's, previous .csv's) into one table  by their respective id.
Due to, these dataframe's inside of a lists, it was a bit tricky to find access.
But anyway, these are so many Id's and i'm lazy i wrote a function again, to do the job.
This time we call her:

**create_big_picture**

***

```{r create_bib_pic, echo=TRUE}

search_for_col_id <- "Id$" 

create_big_picture <- function(finally_all_sorted){
  do_big_picture <- finally_all_sorted$results
  for (kind_of_list in names(finally_all_sorted)){
    if (kind_of_list != "results") { # get sure 'results'table wont get joined into it self
      
      #match_columns <- colnames(finally_all_sorted[[kind_of_list]])[str_detect(colnames(finally_all_sorted[[kind_of_list]]), search_for_col_id)]
      
    match_columns <- grep(search_for_col_id, colnames(finally_all_sorted[[kind_of_list]]), value = TRUE, ignore.case = TRUE)
    do_big_picture <- do_big_picture%>%
      left_join(finally_all_sorted[[kind_of_list]], match_columns)
    }
  }
  return(do_big_picture)
}
big_picture <- create_big_picture(finally_all_sorted)
```

***

Becouse, the funnction is giving us: \n
 
#### **THE BIG Picture**

***

```{r big_pic, echo=FALSE}
head(big_picture)
```

***

 here it is, finally the **Big Picture** i hope i can somehow magical do an fancy html graph out of it, in the lasting hours
otherwise it was just a waste of time to function up all the cleaning

***

 now we have to take a look into the data..., luckily 'wins' already counts the total per season.
        -> needed the cumsum()-function to mutate a new variable with the **total wins**


***

#### Now we need to filter for years of interest and top x .

 And put it all in a function we call:
 **pipe_hammer**
 
***

```{r show_pipe_hammer, echo=TRUE}

pipe_hammer <- big_picture %>% 
  filter(year %in%(2000:2020))%>%
  group_by(year, driverId) %>%
  filter(wins == max(wins))%>%
  slice(1)%>%#                                   <- with and without something is not right need to get rid of doubles or n
  ungroup()%>%
  group_by(driverId)%>%
  mutate(sum_wins_along = cumsum(wins[order(year)]))%>%
  arrange(desc(sum_wins_along))%>%
  ungroup()%>%
  filter(driverId %in% head(unique(driverId[order(sum_wins_along, decreasing = TRUE)]), 10)) %>%
  select(year, forename, surname, nationality, wins, sum_wins_along, name )%>%  #            -> to arrange columns of table in better way, won't be needed if not showing, could be just: select(contains("na(me|tionality)", "wins"), "year") 
  rename("constructor" = name)%>%
   mutate( year = as.factor(year), #                             -> might be a dumb idea to factorize year-number, let's see.......
          constructor = as.factor(constructor))

```
 
 ***
 As you can see, within the pipe we're using:

  - a 'filter()' 
  function to take a look for intrested years, first to reduce data amount were wrangling further .
  
  - 'group_by(year, driverID)%>%' and
  - 'filter(wins == max(wins)) %>%slice(1) %>%' 
  to to know when the season is ove and get season win count
  
  -  'group_by(driverId) %>%
      mutate(sum_wins_along = cumsum(wins[order(year)])) %>%
      arrange(desc(sum_wins_along))'
  to get the total win count per driver, to get on 'cumSum()' probably was the hardest here
  
  - the rest is just same selecting and arranging  and factorizing.
  
  
 ***
### to make it more interesting and interactiv,
 - and variable usuable 
 i used the **shiny package**, as mentioned.
 
 ***

```{r filter_year, echo=FALSE}

ui <- fluidPage(
   fluidRow(
    column(12,
           h3("Here we can define the years of intrest")
    )
  ,
  column(6,
         h4("Select:"),
inputPanel(
  sliderInput("year_from", "starts from:", 1950, 2023, 2000, width = "100%", sep = ""),
  sliderInput("year_to", "until:", 1950, 2023, 2020, width = "100%", sep = ""),
  numericInput("top_n", "Choose the 'Top X' driver", 10, 5, 50, step = 1),
  p("(Note: Top 5 - 50 ")
  )),
  tableOutput("table_head")
))

server <- function(input, output) {
  
  
  output$table_head <- renderTable({
    print("Start filtering")
    
    filter_big_pic <- big_picture %>% 
      filter(year %in% seq(input$year_from, input$year_to)) %>%
      group_by(year, driverId) %>%
      filter(wins == max(wins)) %>%
     slice(1) %>% #                                   <- with and without something is not right
      ungroup() %>%
      group_by(driverId) %>%
      mutate(sum_wins_along = cumsum(wins[order(year)])) %>%
      arrange(desc(sum_wins_along)) %>%
      ungroup() %>%
      filter(driverId %in% head(unique(driverId[order(sum_wins_along, decreasing = TRUE)]), input$top_n)) %>%
      select(year, forename, surname, nationality, wins, sum_wins_along, name ) %>%
      rename("constructor" = name) %>%
      mutate(
        year = as.factor(year),
        constructor = as.factor(constructor)
      )
    
    print("Data filtered")
    
    head( filter_big_pic, 5)
  })
}

shinyApp(ui, server)

```


***
  
**This already looking pretty dope right, but were not done yet...**

        Note: ..but sadly i coudn't figure out how to store/cache this interactiv shiny output
              for the next step to tidy it up.
              So we use the "pipe_hammer" to go oon.

***

### Next we need to make the data tidy to get it visualized

***

I tried to get my head around, whats the appropriate structure for.

My first assumption be to apply the 'pivot_longer' to each <datatyp>

And again, cous im tired, writting stuff twice, i wrote a function to:

  - identify unique <datatyp> in a Dataframe,
  - and generate a list of lists(datatyp) with column (names)
  
  This time we just call her:
  **find_datayps_classes**
  
***

```{r filter_datatyp, echo = TRUE,  eval = TRUE}
find_datayps_classes <- function(df){
  uniq_datatypes_in_df <- unique(sapply(df, class))        # stores vector of unique datatypes via typeof-func
  col_names_of_all_datatyp <- list()
  
  for (datatyp in uniq_datatypes_in_df) {
    col_name <- names(df)[sapply(df, class) == datatyp]
    col_names_of_all_datatyp[[datatyp]] <- col_name
  }
  return(col_names_of_all_datatyp)
}
showMe <- find_datayps_classes(pipe_hammer)

```

***

To take a look **hit the button** below

***

```{r shinyalert, echo=FALSE}


# 
actionButton("show_datatyp_button", "Show column <datatyp>")


observeEvent(input$show_datatyp_button, {
  structure_text <- capture.output(showMe)
  shinyalert(
    title = "show Me datatyp",
    text = paste(structure_text, collapse = "\n"),
    type = "info"
  )
})

```

***

Next we just need to pivot_long a column for each <datatyp>
and of course we're using a function
to create our:
**pivot_all_at_once**


***

```{r piv_long, echo=TRUE}

pivot_all_at_once <- function(df,showMe){
  long_df <- df
  
  for (dataclass in names(showMe)) {
    columns <- showMe[[dataclass]]
    names_to <- paste0(substr(dataclass, 1, 8), "_typ")
    values_to <- paste0(substr(dataclass, 1, 3), "_wert")

    long_df <- long_df%>%
      pivot_longer(cols = all_of(columns), names_to = names_to, values_to = values_to )
  }
  return(long_df)
}

```

***

### To finaly create our **final_long_picture**:

***

```{r final_pic, echo=TRUE}
final_long_picture <- pivot_all_at_once(pipe_hammer, showMe)
final_long_picture
```

***

## Now we can start the visualization Part: `r emo::ji("beer")`

***


