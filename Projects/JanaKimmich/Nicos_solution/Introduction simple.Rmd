---
title: "Fomula One Solution simple"
author: "Nicolai Schwarz"
date: "2023-12-18"
output: html_document
---
```{r setup, include=FALSE}
# get this packages

source("install_packages_simple.R")
library(tidyverse)
library(emo)
library(readr)
knitr::opts_chunk$set(echo = TRUE)
# rm(list = ls())
```

# This is my **Formula One Solution**

### Dear Jana,

after i first took a closer look in your provided `archive.zip`and sorted out the `.csv` tables of intrest.

My first thoughts been its just some selecting/deselecting and joining and go on with the visualization part.

Honestly i even tried to cheat and prepared the `.csv`s already with **OpenRefine** `r emo::ji("grin")` [Download Link](https://github.com/OpenRefine/OpenRefine/releases/download/3.7.6/openrefine-win-with-java-3.7.6.zip)

But by accident i imported the wrong `.csv` dats and already after trying to import the second `.csv` from your provided  [archive.zip](https://github.com/Dr-Eberle-Zentrum/Data-projects-with-R-and-GitHub/blob/main/Projects/JanaKimmich/archive.zip) folder, i came to this wunderful idea of creating this [**drop_n_slice_folder**](https://github.com/Dr-Eberle-Zentrum/Data-projects-with-R-and-GitHub/tree/Nicos_tryOut_branch/Jana_Formula_One/drop_n_slice_folder) for you ! `r emo::ji("grin")`


I  wasn't actuall sure if you wanna extend this project anytime to the other `.csv` dats aswell, but it should work with some minor adjustments.
  
*I didn't fully wrapped my head around already, mightbe snippets could be recycled, for the:*
[**SOP-Issue**](https://github.com/Dr-Eberle-Zentrum/Data-projects-with-R-and-GitHub/blob/main/Projects/blubbi90/StandardOperatingProcedureLayout/project_description_v0.1.md)

***

I found it prettxy intresting and useful to see the **Top-10** Winners of diffrent years as well, so i used an [Interactive RMD Documents](http://rmarkdown.rstudio.com/authoring_shiny.html).
With the ***shiny package***',  you can embed Shiny inputs and outputs in your document. Outputs are automatically updated whenever inputs change.

(*If you wanna learn more about, click the* [*Link*](http://rmarkdown.rstudio.com/authoring_shiny.html))

        Note: I didnt get it working proper, so this will only be the simple static Markdown file version.

***

So let us come back to this fantastic [**drop_n_slice_folder**](https://github.com/Dr-Eberle-Zentrum/Data-projects-with-R-and-GitHub/tree/Nicos_tryOut_branch/Jana_Formula_One/drop_n_slice_folder)  `r emo::ji("folder")` and let's have an closer look how it actuall works and helps to solve [your **Formula One Issue:**](https://github.com/Dr-Eberle-Zentrum/Data-projects-with-R-and-GitHub/blob/main/Projects/JanaKimmich/project-description.md)

***

##  The **Drop_n_slice folder** `r emo::ji("folder")`!!

***
#### So let us take a look inside the folder.

***
```{r folder_content, echo=FALSE}
folder_path <- "C:\\Users\\Pirate\\Documents\\Data-projects-with-R-and-GitHub\\Projects\\JanaKimmich\\Nicos_solution\\Solution\\drop_n_slice"

 files <- list.files(folder_path)

files
```

***

So you can see, we identified all `.csv`'s with the tables of interest,
  and pushed them together in the **drop_n_slice folder**.
  
The rest of the .csv's is in the **commit_out folder**.

They could easily added, if data inside is of interest,
  and is related/connected in anyway within the `result.csv`.
  
  *(current by containing (column ID)*

***

### Now we need to import all these .csv tables into R, best all at once

***

Therefor I wrote you an function ( `auto_import_csv` ), which do exactly that.


*You know i'm lazy* `r emo::ji("grin")`

But first:
```{r wd, echo=TRUE}
#drop_path <- file.path(getwd(), "Solution/drop_n_slice")
drop_path <- "C:\\Users\\Pirate\\Documents\\Data-projects-with-R-and-GitHub\\Projects\\JanaKimmich\\Nicos_solution\\Solution\\drop_n_slice"

```

***

Here we define the folder-path, which contains the table's of interest and should be imported

***

```{r import, echo=TRUE }

auto_import_csv <- function(file_path){
  
  file_list <- list.files(path = file_path, pattern = "\\.csv$", full.names = TRUE)        #-> here we could change the auto import to other data type's 
  data_frames <- list()
  
  for (file in file_list) {
    df_name <- tools::file_path_sans_ext(basename(file))  # uses filename as dataframe
    data_frames[[df_name]] <- read.csv(file)
  }
  
  return(data_frames)
}
once_in_all_together <- auto_import_csv(drop_path)

```

***

 And ***magic appear***, it pushes us all tables of interest in One big list of dataframe together , calling it `once_in_all_together`
 
***

#### Let's take a look into the structure of:

 **once_in_all_together:**
 
***

```{r str_once_in_all, echo=FALSE}
str(once_in_all_together)

```

***

**Okay this big bastard is a way to fat and ugly, lets slice em down** of the columns of interest.


***

### Therefor, you've probably already guessed, i created a function:

We'll call it **the big_slicer**

Now let's finish the job:

***

```{r big_slicer, echo=TRUE}

big_slicer <- function(on_tibble_list){
  tibble_list_intrest_col <- sapply(on_tibble_list, function(on_each_tibble){
    
    # might be better to store searching patter outside of the function 4 better edit control
    
    select_columns_of_intrest <- select(on_each_tibble, matches("^(result|race|driver|constructor)Id$"), contains("name"), matches("nationality"), matches("wins"), matches("year")) # matches("points"), matches("^positionOrder$"), matches("rank"
    return(select_columns_of_intrest)
    })
  return(tibble_list_intrest_col)
}

slice_it <- big_slicer(once_in_all_together)
```

***
I created a search list, but dunno, the **bang_bang_bang_operator** is not willing to **!!! bang**  the list inside the select-function !

***

`search_list <- list(`

 `matches("^(result|race|driver|constructor)Id$"),`
 
  `contains("name"),`
  
  `matches("nationality"),`
  
  `matches("wins"),`
  
  `matches("year")`

***

*kaquing* let's take a look what we got left in:

**slice_it:**

***

```{r str_slice_it, echo=FALSE}

str(slice_it)

```

***

***looks pretty dope ain't !?***

Okay, okay, there's still some fine tuning to be done...

...let's get this final surgery manually done.

***

And sort out the unnecessary:

- `names` in races,
- `nationality` in constructors.

*** 

```{r final_cut, echo=TRUE}
{
slice_it$races <- slice_it$races %>% # should work with map anyhow aswell
  select(-name)

slice_it$constructors <- slice_it$constructors %>%
  select(-nationality)

finally_all_sorted <- slice_it
}
```

***

If we take now a closer look at the structure of:


**finally_all_sorted:**

***

```{r str_finally_all_sorted, echo=FALSE}

str(finally_all_sorted)
```

***

We can see, we **only** got the columns of interest left and those containing `Id`.

***

**Next:** 

We want to get all data frame's (table's, previous .csv's) into one table  by their respective Id-column.

Due to, these data frame's are inside of a lists, it was a bit tricky to find access.

But anyway, these are so many Id's and I'm lazy. 
So i wrote a function again, to do the job.

This time we call it:

**create_big_picture:**

***

```{r create_bib_pic, echo=TRUE}

search_for_col_id <- "Id$" 

create_big_picture <- function(finally_all_sorted){
  do_big_picture <- finally_all_sorted$results
  for (kind_of_list in names(finally_all_sorted)){
    if (kind_of_list != "results") { # get sure 'results'table wont get joined into it self
      
      #match_columns <- colnames(finally_all_sorted[[kind_of_list]])[str_detect(colnames(finally_all_sorted[[kind_of_list]]), search_for_col_id)]
      
    match_columns <- grep(search_for_col_id, colnames(finally_all_sorted[[kind_of_list]]), value = TRUE, ignore.case = TRUE)
    do_big_picture <- do_big_picture%>%
      left_join(finally_all_sorted[[kind_of_list]], match_columns)
    }
  }
  return(do_big_picture)
}
big_picture <- create_big_picture(finally_all_sorted)
```

***

Because, the function is giving us:
 
#### **THE BIG Picture:**

***

```{r big_pic, echo=FALSE}
head(big_picture)
```

***

**Here** it is, finally the **Big Picture !** 
 
      I hope i can somehow magical do an fancy html graph out of it, in the lasting hours
      otherwise it was just a waste of time to function up all the cleaning

***

 **Now** let's have  a look into the data...
 
 ... luckily the column `wins` already counts the total wins per season.
 
        -> needed the cumsum()-function
        
to mutate a new variable: 

`total wins`


***

#### Next we need to filter for:

  - year's of interest
  - top x drivers.
  
  ***

 And put it all in a pipe so called:
 
 **pipe_hammer**
 
***

```{r show_pipe_hammer, echo=TRUE}

pipe_hammer <- big_picture %>% 
  filter(year %in%(2000:2020))%>%
  group_by(year, driverId) %>%
  filter(wins == max(wins))%>%
  distinct(driverId, year, wins,.keep_all=TRUE)%>% #slice(1)%>%#                                   <- with and without something is not right need to get rid of doubles or n
  ungroup()%>%
  group_by(driverId)%>%
  mutate(sum_wins_along = cumsum(wins[order(year)]))%>%
  arrange(desc(sum_wins_along))%>%
  ungroup()%>%
  filter(driverId %in% head(unique(driverId[order(sum_wins_along, decreasing = TRUE)]), 10)) %>%
  select(year, forename, surname, nationality, wins, sum_wins_along, name )%>%  #            -> to arrange 
  
                            #columns of table in better way, won't be needed if not showing, could be just:  
  
                            #select(contains("na(me|tionality)", "wins"), "year") 
  
  rename("constructor" = name)%>%
   mutate( year = as.factor(year), #                             -> might be a dumb idea to factorize
           
                                                                  #year-number, let's see.......
          constructor = as.factor(constructor))

```
 
 ***
 
 **As you can see, within the pipe we're using:**

  - first  a `filter()`-function to look for years of interest and reduce the data amount wer'e further wrangling with.
  
  - `group_by(year, driverID)%>%` and
  - `filter(wins == max(wins)) %>%slice(1) %>%`
  
  
 to know when the season is over and to get the total season win count only once
  
  -  `group_by(driverId) %>%`
  
      `mutate(sum_wins_along = cumsum(wins[order(year)])) %>%`
      
      `arrange(desc(sum_wins_along))`
      
to get the total win count per driver.
  
        -> to know to apply the `cumSum()`-function here, was probably  the hardest.
  
  - the rest is just same selecting and arranging  and factorizing.
  
  
***

#### **Let's have a look in the output:**

***

```{r,  echo = FALSE}
pipe_hammer
```

***

**This already looks pretty dope right, but we're not done yet...**

    
***

#### Next we need to tidy up the data to get it fancy visualized

***

I tried to get my head around, whats the appropriate structure for.

My first assumption be to apply the `pivot_longer`-function to each \<datatyp> class.

And again, couse i'm tired, writing stuff twice, i wrote a function to:

  - identify unique \<datatyp> in a Dataframe,
  - and generate a list of lists(datatyps) with column (names)
  
  This time we just call it:
  
  **find_datayps_classes**
  
***

```{r filter_datatyp, echo = TRUE,  eval = TRUE}
find_datayps_classes <- function(df){
  uniq_datatypes_in_df <- unique(sapply(df, class))        # stores vector of unique datatypes via typeof-func
  col_names_of_all_datatyp <- list()
  
  for (datatyp in uniq_datatypes_in_df) {
    col_name <- names(df)[sapply(df, class) == datatyp]
    col_names_of_all_datatyp[[datatyp]] <- col_name
  }
  return(col_names_of_all_datatyp)
}
showMe <- find_datayps_classes(pipe_hammer)

```

***
```{r, echo=FALSE}
showMe
```

***

Okay okay I'm not sure if it was necessary for the next step or useful at all,\n
but anyway, might be of interest to recycle

***

**Finally** we apply the  `pivot_long`-function \n

to all columns of the corresponding \<datatyp>.

Of course we're using a function that for .

Here :

**pivot_all_at_once:**

***

```{r piv_long, echo=TRUE}

pivot_all_at_once <- function(df,showMe){
  long_df <- df
  
  for (dataclass in names(showMe)) {
    columns <- showMe[[dataclass]]
    names_to <- paste0(substr(dataclass, 1, 8), "_typ")
    values_to <- paste0(substr(dataclass, 1, 4), "_wert")

    long_df <- long_df%>%
      pivot_longer(cols = all_of(columns), names_to = names_to, values_to = values_to )
  }
  return(long_df)
}

```

***

 To finally create our:
 
 **final_long_picture:**:

***

```{r final_pic, echo=FALSE}
final_long_picture <- pivot_all_at_once(pipe_hammer, showMe)
final_long_picture
```

***

## Now we can start the visualization Part: `r emo::ji("beer")`

***

After the first attempts i already recognized, the `final-long_picture`data structure **sucks** for the task.

**Let's** try it with the `pipe_hammer` structure, before we'd tried to *"tidy up"* the data.

Ok i see, for better computation we should bring the fore-surname together in one cell as `full_name`

```{r combine-name , echo=TRUE}

name_combined <- pipe_hammer %>%
  mutate(full_name = paste(forename, surname, sep = " "))%>%
  select(-c(forename, surname))
name_combined


```

***

Yes we also could put this in the `pipe_hammer` later, first let's see if we can go on from here more easy.

***
```{r ggplot, echo=TRUE}

# Reorder full_name based on wins

name_combined$full_name <- reorder(name_combined$full_name, name_combined$wins)


plot1 <- ggplot(data = name_combined, aes(x = full_name, fill = constructor)) +
  geom_bar() +
  coord_flip()+
  scale_y_continuous(breaks = seq(min(name_combined$wins), max(name_combined$sum_wins_along), by = 10)) +
  theme_minimal()+
  theme(axis.title.y = element_blank())

# Add constructor color
plot2 <- plot1 + geom_bar(aes(y = wins, color = constructor), stat = "identity")

plot2 <- plot2 + labs(y = "Races won",
                      title = "Most successful drivers with \nconstructors",
                      subtitle = "click on bar to open wikipedia page of driver")

# center title and make it bigger
plot2 <- plot2 + theme(plot.title = element_text(size = 20,
                                                 hjust = 0.6),
                       plot.subtitle = element_text(hjust = 0.6))

print(plot2)

```
