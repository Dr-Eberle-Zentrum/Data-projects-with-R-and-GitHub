<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="en" xml:lang="en"><head>

<meta charset="utf-8">
<meta name="generator" content="quarto-1.5.56">

<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes">


<title>miguel-solution</title>
<style>
code{white-space: pre-wrap;}
span.smallcaps{font-variant: small-caps;}
div.columns{display: flex; gap: min(4vw, 1.5em);}
div.column{flex: auto; overflow-x: auto;}
div.hanging-indent{margin-left: 1.5em; text-indent: -1.5em;}
ul.task-list{list-style: none;}
ul.task-list li input[type="checkbox"] {
  width: 0.8em;
  margin: 0 0.8em 0.2em -1em; /* quarto-specific, see https://github.com/quarto-dev/quarto-cli/issues/4556 */ 
  vertical-align: middle;
}
</style>


<script src="Miguel-solution_files/libs/clipboard/clipboard.min.js"></script>
<script src="Miguel-solution_files/libs/quarto-html/quarto.js"></script>
<script src="Miguel-solution_files/libs/quarto-html/popper.min.js"></script>
<script src="Miguel-solution_files/libs/quarto-html/tippy.umd.min.js"></script>
<script src="Miguel-solution_files/libs/quarto-html/anchor.min.js"></script>
<link href="Miguel-solution_files/libs/quarto-html/tippy.css" rel="stylesheet">
<link href="Miguel-solution_files/libs/quarto-html/quarto-syntax-highlighting.css" rel="stylesheet" id="quarto-text-highlighting-styles">
<script src="Miguel-solution_files/libs/bootstrap/bootstrap.min.js"></script>
<link href="Miguel-solution_files/libs/bootstrap/bootstrap-icons.css" rel="stylesheet">
<link href="Miguel-solution_files/libs/bootstrap/bootstrap.min.css" rel="stylesheet" id="quarto-bootstrap" data-mode="light">


</head>

<body class="fullcontent">

<div id="quarto-content" class="page-columns page-rows-contents page-layout-article">

<main class="content" id="quarto-document-content">




<section id="load-the-data" class="level2">
<h2 class="anchored" data-anchor-id="load-the-data">Load the data</h2>
<p>First let’s load the data.</p>
<pre><code># Load necessary libraries
library(here)
library(readr)
library(purrr)
library(magrittr)
library(dplyr)

list.files(path = here("Projects/DrMohamedElsherif/BikeData"), pattern = "*.csv", full.names = TRUE) %&gt;% 
    set_names(nm = tools::file_path_sans_ext(basename(.))) %&gt;% 
    walk2(.x = ., .y = names(.), ~ assign(.y, read_csv(.x), envir = .GlobalEnv))</code></pre>
</section>
<section id="merge-the-data" class="level2">
<h2 class="anchored" data-anchor-id="merge-the-data">Merge the data</h2>
<p>The data frame bike_counts contains the number of bikes that passed through each point every hour and the weather data frame contains the weather information for each hour. We need to merge both data frames to analyze the relationship between the number of bikes and the weather. Since the data frames cointain a column with the date and hour, we can use this column to merge the data frames.</p>
<pre><code># Merge the data frames
bike_data &lt;- merge(bike_counts, weather, by = "time")
head(bike_data)

##                  time bike_count channel_id counter_site_id temperature
## 1 2018-01-01 01:00:00         18  102003358       100003358           9
## 2 2018-01-01 01:00:00          3  101026408       100026408           9
## 3 2018-01-01 01:00:00         23  101003358       100003358           9
## 4 2018-01-01 01:00:00          1  102026408       100026408           9
## 5 2018-01-01 01:00:00          0  102003359       100003359           9
## 6 2018-01-01 01:00:00          0  101003359       100003359           9
##   windspeed humidity heaven rain snow thunderstorms fog
## 1         9       71      5    0    0             0   0
## 2         9       71      5    0    0             0   0
## 3         9       71      5    0    0             0   0
## 4         9       71      5    0    0             0   0
## 5         9       71      5    0    0             0   0
## 6         9       71      5    0    0             0   0</code></pre>
</section>
<section id="explore-the-data-to-find-missing-values" class="level2">
<h2 class="anchored" data-anchor-id="explore-the-data-to-find-missing-values">Explore the data to find missing values</h2>
<p>Let’s explore the data to find missing values.</p>
<pre><code># Number of missing values
colSums(is.na(bike_data))

##            time      bike_count      channel_id counter_site_id     temperature 
##               0               0               0               0               0 
##       windspeed        humidity          heaven            rain            snow 
##               0               0               0               0               0 
##   thunderstorms             fog 
##               0               0</code></pre>
<p>No missing values were found, however, we only teste for NA values. We need to check if there are any other type of missing values as zeros in the channel_id or counter_site_id column</p>
<pre><code># Number of zeros in the channel_id column
sum(bike_data$channel_id == 0)

## [1] 0

# Number of zeros in the counter_site_id column
sum(bike_data$counter_site_id == 0)

## [1] 0</code></pre>
<p>No outliers were found in the channel_id or counter_site_id columns. We can now proceed with the analysis.</p>
</section>
<section id="plot-the-data" class="level2">
<h2 class="anchored" data-anchor-id="plot-the-data">Plot the data</h2>
<p>Lets plot the number of bikes that passed through each point every hour separating the data by counter_site_id and group by the hour of the day.</p>
<pre><code>library(ggplot2)
library(dplyr)

# Extract the hour from the time column adding it as a new column
bike_data$hour &lt;- as.numeric(format(bike_data$time, "%H"))

# Agrupar por hour y counter_site_id, y sumar bike_count
bike_data_per_hour &lt;- bike_data %&gt;%
    group_by(hour, counter_site_id) %&gt;%
    summarise(bike_count = sum(bike_count), .groups = 'drop')

bike_data_per_hour$counter_site_id &lt;- as.factor(bike_data_per_hour$counter_site_id)

# Plot
ggplot(bike_data_per_hour, aes(x = hour, y = bike_count, color = counter_site_id, group = counter_site_id)) +
    geom_line() +
    labs(title = "Number of bikes by counter site and hour", x = "Hour", y = "Number of bikes")+ 
    theme_minimal() +
    theme(panel.grid.major = element_blank(), panel.grid.minor = element_blank(),
          panel.background = element_blank(), axis.line = element_line(colour = "black"))</code></pre>
<p><img src="Miguel-solution_files/figure-markdown_strict/plot-data-1.png" class="img-fluid"></p>
<p>We can see that the number of bikes that pass through each point varies throughout the day. There is a peak in the morning and another in the afternoon. The number of bikes is higher in the afternoon than in the morning.</p>
</section>
<section id="analyze-the-relationship-between-the-number-of-bikes-and-the-weather" class="level2">
<h2 class="anchored" data-anchor-id="analyze-the-relationship-between-the-number-of-bikes-and-the-weather">Analyze the relationship between the number of bikes and the weather</h2>
<p>Let’s plot the number of bikes that passed through each point every hour and the weather information. We will create a new data frame with the sum of the number of bikes by hour in all the counter sites and merge it with the weather data frame.</p>
<pre><code>bike_data_weather &lt;- bike_data %&gt;%
    mutate(time = as.POSIXct(time, format = "%Y-%m-%d %H:%M:%S")) %&gt;%
    group_by(time) %&gt;% 
    summarise(bike_count = sum(bike_count), .groups = 'drop') %&gt;%
    left_join(weather, by = "time")</code></pre>
<p>Now we will plot the number of bikes per hour in the Y axe against the temperature in the X axe.</p>
<pre><code>ggplot(bike_data_weather, aes(x = temperature, y = bike_count)) +
    geom_point() +
    labs(title = "Number of bikes by temperature", x = "Temperature", y = "Number of bikes")+
    theme_minimal() + 
    theme(panel.grid.major = element_blank(), panel.grid.minor = element_blank(),
          panel.background = element_blank(), axis.line = element_line(colour = "black"))</code></pre>
<p><img src="Miguel-solution_files/figure-markdown_strict/plot-relationship-1.png" class="img-fluid"> In this plot we can see that the number of bikes that pass through each point increases as the temperature increases. There is a positive relationship between the number of bikes and the temperature.</p>
<p>We may add a linear regression line to the plot to visualize the relationship between the number of bikes and the temperature.</p>
<pre><code>ggplot(bike_data_weather, aes(x = temperature, y = bike_count)) +
    geom_point() +
    geom_smooth(method = "lm") +
    labs(title = "Number of bikes by temperature", x = "Temperature", y = "Number of bikes")+
    theme_minimal() + 
    theme(panel.grid.major = element_blank(), panel.grid.minor = element_blank(),
          panel.background = element_blank(), axis.line = element_line(colour = "black"))+
          #add the R squared value
    annotate("text", x = -10, y = 2000, label = paste("R^2 =", round(summary(lm(bike_count ~ snow, data = bike_data_weather))$r.squared, 4)), hjust = 0, vjust = 1)

## `geom_smooth()` using formula = 'y ~ x'</code></pre>
<p><img src="Miguel-solution_files/figure-markdown_strict/plot-relationship2-1.png" class="img-fluid"></p>
<p>Regardless the positive relationship between the number of bikes and the temperature, the R squared value is very low, which means that the temperature is not a good predictor of the number of bikes.</p>
<p>We can do the same analysis with the snow column.</p>
<pre><code>ggplot(bike_data_weather, aes(x = snow, y = bike_count)) +
    geom_point() +
    geom_smooth(method = "lm") +
    labs(title = "Number of bikes by snow", x = "Snow", y = "Number of bikes")+
    theme_minimal() + 
    theme(panel.grid.major = element_blank(), panel.grid.minor = element_blank(),
        panel.background = element_blank(), axis.line = element_line(colour = "black"))+
    annotate("text", x = 0, y = 2000, label = paste("R^2 =", round(summary(lm(bike_count ~ snow, data = bike_data_weather))$r.squared, 4)), hjust = 0, vjust = 1)

## `geom_smooth()` using formula = 'y ~ x'</code></pre>
<p><img src="Miguel-solution_files/figure-markdown_strict/plot-relationship3-1.png" class="img-fluid"></p>
<p>In the case of the snow, a low R squared value is obtained, which means that the snow is not a good predictor of the number of bikes. This may be because even when it is not snowing, the stations register a low number of bikes. The reason may be related to failed sensors or other factors that are not related to the weather.</p>
<p>Let’s analyze if the rain is a good predictor of the number of bikes.</p>
<pre><code>ggplot(bike_data_weather, aes(x = rain, y = bike_count)) +
    geom_point() +
    geom_smooth(method = "lm") +
    labs(title = "Number of bikes by rain", x = "Rain", y = "Number of bikes")+
    theme_minimal() + 
    theme(panel.grid.major = element_blank(), panel.grid.minor = element_blank(),
        panel.background = element_blank(), axis.line = element_line(colour = "black"))+
    annotate("text", x = 0, y = 2000, label = paste("R^2 =", round(summary(lm(bike_count ~ rain, data = bike_data_weather))$r.squared, 4)), hjust = 0, vjust = 1)

## `geom_smooth()` using formula = 'y ~ x'</code></pre>
<p><img src="Miguel-solution_files/figure-markdown_strict/plot-relationship4-1.png" class="img-fluid"></p>
<p>It is interesting to notiece that in the days of rain and snow, the records of the stations are lower than in the days without rain or snow. This is because the sensors may be affected by the weather. Also it could be possible that the points are being overploted in the plot, so we may need to check the number of records for each type of weather.</p>
<pre><code>bike_data_weather %&gt;%
    count(rain)

## # A tibble: 9 × 2
##    rain     n
##   &lt;dbl&gt; &lt;int&gt;
## 1     0 40590
## 2     1  1105
## 3     2   384
## 4     3  2964
## 5     4   168
## 6     5   685
## 7     6   233
## 8     7    12
## 9     8     6</code></pre>
<p>As we can see, the number of records for the days without rain is higher than the number of records for the days with rain.</p>
<p>Let’s do the same for the snow column.</p>
<pre><code>bike_data_weather %&gt;%
    count(snow)

## # A tibble: 11 × 2
##     snow     n
##    &lt;dbl&gt; &lt;int&gt;
##  1     0 45066
##  2     1   650
##  3     2     3
##  4     3   124
##  5     4    23
##  6     6    66
##  7     7    17
##  8     8   189
##  9     9     1
## 10    10     4
## 11    11     4</code></pre>
<p>The number of records for the days without snow is higher than the number of records for the days with snow. This lead us to the conclusion that the weather may be affecting the sensors of the stations.</p>
</section>

</main>
<!-- /main column -->
<script id="quarto-html-after-body" type="application/javascript">
window.document.addEventListener("DOMContentLoaded", function (event) {
  const toggleBodyColorMode = (bsSheetEl) => {
    const mode = bsSheetEl.getAttribute("data-mode");
    const bodyEl = window.document.querySelector("body");
    if (mode === "dark") {
      bodyEl.classList.add("quarto-dark");
      bodyEl.classList.remove("quarto-light");
    } else {
      bodyEl.classList.add("quarto-light");
      bodyEl.classList.remove("quarto-dark");
    }
  }
  const toggleBodyColorPrimary = () => {
    const bsSheetEl = window.document.querySelector("link#quarto-bootstrap");
    if (bsSheetEl) {
      toggleBodyColorMode(bsSheetEl);
    }
  }
  toggleBodyColorPrimary();  
  const icon = "";
  const anchorJS = new window.AnchorJS();
  anchorJS.options = {
    placement: 'right',
    icon: icon
  };
  anchorJS.add('.anchored');
  const isCodeAnnotation = (el) => {
    for (const clz of el.classList) {
      if (clz.startsWith('code-annotation-')) {                     
        return true;
      }
    }
    return false;
  }
  const onCopySuccess = function(e) {
    // button target
    const button = e.trigger;
    // don't keep focus
    button.blur();
    // flash "checked"
    button.classList.add('code-copy-button-checked');
    var currentTitle = button.getAttribute("title");
    button.setAttribute("title", "Copied!");
    let tooltip;
    if (window.bootstrap) {
      button.setAttribute("data-bs-toggle", "tooltip");
      button.setAttribute("data-bs-placement", "left");
      button.setAttribute("data-bs-title", "Copied!");
      tooltip = new bootstrap.Tooltip(button, 
        { trigger: "manual", 
          customClass: "code-copy-button-tooltip",
          offset: [0, -8]});
      tooltip.show();    
    }
    setTimeout(function() {
      if (tooltip) {
        tooltip.hide();
        button.removeAttribute("data-bs-title");
        button.removeAttribute("data-bs-toggle");
        button.removeAttribute("data-bs-placement");
      }
      button.setAttribute("title", currentTitle);
      button.classList.remove('code-copy-button-checked');
    }, 1000);
    // clear code selection
    e.clearSelection();
  }
  const getTextToCopy = function(trigger) {
      const codeEl = trigger.previousElementSibling.cloneNode(true);
      for (const childEl of codeEl.children) {
        if (isCodeAnnotation(childEl)) {
          childEl.remove();
        }
      }
      return codeEl.innerText;
  }
  const clipboard = new window.ClipboardJS('.code-copy-button:not([data-in-quarto-modal])', {
    text: getTextToCopy
  });
  clipboard.on('success', onCopySuccess);
  if (window.document.getElementById('quarto-embedded-source-code-modal')) {
    // For code content inside modals, clipBoardJS needs to be initialized with a container option
    // TODO: Check when it could be a function (https://github.com/zenorocha/clipboard.js/issues/860)
    const clipboardModal = new window.ClipboardJS('.code-copy-button[data-in-quarto-modal]', {
      text: getTextToCopy,
      container: window.document.getElementById('quarto-embedded-source-code-modal')
    });
    clipboardModal.on('success', onCopySuccess);
  }
    var localhostRegex = new RegExp(/^(?:http|https):\/\/localhost\:?[0-9]*\//);
    var mailtoRegex = new RegExp(/^mailto:/);
      var filterRegex = new RegExp('/' + window.location.host + '/');
    var isInternal = (href) => {
        return filterRegex.test(href) || localhostRegex.test(href) || mailtoRegex.test(href);
    }
    // Inspect non-navigation links and adorn them if external
 	var links = window.document.querySelectorAll('a[href]:not(.nav-link):not(.navbar-brand):not(.toc-action):not(.sidebar-link):not(.sidebar-item-toggle):not(.pagination-link):not(.no-external):not([aria-hidden]):not(.dropdown-item):not(.quarto-navigation-tool):not(.about-link)');
    for (var i=0; i<links.length; i++) {
      const link = links[i];
      if (!isInternal(link.href)) {
        // undo the damage that might have been done by quarto-nav.js in the case of
        // links that we want to consider external
        if (link.dataset.originalHref !== undefined) {
          link.href = link.dataset.originalHref;
        }
      }
    }
  function tippyHover(el, contentFn, onTriggerFn, onUntriggerFn) {
    const config = {
      allowHTML: true,
      maxWidth: 500,
      delay: 100,
      arrow: false,
      appendTo: function(el) {
          return el.parentElement;
      },
      interactive: true,
      interactiveBorder: 10,
      theme: 'quarto',
      placement: 'bottom-start',
    };
    if (contentFn) {
      config.content = contentFn;
    }
    if (onTriggerFn) {
      config.onTrigger = onTriggerFn;
    }
    if (onUntriggerFn) {
      config.onUntrigger = onUntriggerFn;
    }
    window.tippy(el, config); 
  }
  const noterefs = window.document.querySelectorAll('a[role="doc-noteref"]');
  for (var i=0; i<noterefs.length; i++) {
    const ref = noterefs[i];
    tippyHover(ref, function() {
      // use id or data attribute instead here
      let href = ref.getAttribute('data-footnote-href') || ref.getAttribute('href');
      try { href = new URL(href).hash; } catch {}
      const id = href.replace(/^#\/?/, "");
      const note = window.document.getElementById(id);
      if (note) {
        return note.innerHTML;
      } else {
        return "";
      }
    });
  }
  const xrefs = window.document.querySelectorAll('a.quarto-xref');
  const processXRef = (id, note) => {
    // Strip column container classes
    const stripColumnClz = (el) => {
      el.classList.remove("page-full", "page-columns");
      if (el.children) {
        for (const child of el.children) {
          stripColumnClz(child);
        }
      }
    }
    stripColumnClz(note)
    if (id === null || id.startsWith('sec-')) {
      // Special case sections, only their first couple elements
      const container = document.createElement("div");
      if (note.children && note.children.length > 2) {
        container.appendChild(note.children[0].cloneNode(true));
        for (let i = 1; i < note.children.length; i++) {
          const child = note.children[i];
          if (child.tagName === "P" && child.innerText === "") {
            continue;
          } else {
            container.appendChild(child.cloneNode(true));
            break;
          }
        }
        if (window.Quarto?.typesetMath) {
          window.Quarto.typesetMath(container);
        }
        return container.innerHTML
      } else {
        if (window.Quarto?.typesetMath) {
          window.Quarto.typesetMath(note);
        }
        return note.innerHTML;
      }
    } else {
      // Remove any anchor links if they are present
      const anchorLink = note.querySelector('a.anchorjs-link');
      if (anchorLink) {
        anchorLink.remove();
      }
      if (window.Quarto?.typesetMath) {
        window.Quarto.typesetMath(note);
      }
      // TODO in 1.5, we should make sure this works without a callout special case
      if (note.classList.contains("callout")) {
        return note.outerHTML;
      } else {
        return note.innerHTML;
      }
    }
  }
  for (var i=0; i<xrefs.length; i++) {
    const xref = xrefs[i];
    tippyHover(xref, undefined, function(instance) {
      instance.disable();
      let url = xref.getAttribute('href');
      let hash = undefined; 
      if (url.startsWith('#')) {
        hash = url;
      } else {
        try { hash = new URL(url).hash; } catch {}
      }
      if (hash) {
        const id = hash.replace(/^#\/?/, "");
        const note = window.document.getElementById(id);
        if (note !== null) {
          try {
            const html = processXRef(id, note.cloneNode(true));
            instance.setContent(html);
          } finally {
            instance.enable();
            instance.show();
          }
        } else {
          // See if we can fetch this
          fetch(url.split('#')[0])
          .then(res => res.text())
          .then(html => {
            const parser = new DOMParser();
            const htmlDoc = parser.parseFromString(html, "text/html");
            const note = htmlDoc.getElementById(id);
            if (note !== null) {
              const html = processXRef(id, note);
              instance.setContent(html);
            } 
          }).finally(() => {
            instance.enable();
            instance.show();
          });
        }
      } else {
        // See if we can fetch a full url (with no hash to target)
        // This is a special case and we should probably do some content thinning / targeting
        fetch(url)
        .then(res => res.text())
        .then(html => {
          const parser = new DOMParser();
          const htmlDoc = parser.parseFromString(html, "text/html");
          const note = htmlDoc.querySelector('main.content');
          if (note !== null) {
            // This should only happen for chapter cross references
            // (since there is no id in the URL)
            // remove the first header
            if (note.children.length > 0 && note.children[0].tagName === "HEADER") {
              note.children[0].remove();
            }
            const html = processXRef(null, note);
            instance.setContent(html);
          } 
        }).finally(() => {
          instance.enable();
          instance.show();
        });
      }
    }, function(instance) {
    });
  }
      let selectedAnnoteEl;
      const selectorForAnnotation = ( cell, annotation) => {
        let cellAttr = 'data-code-cell="' + cell + '"';
        let lineAttr = 'data-code-annotation="' +  annotation + '"';
        const selector = 'span[' + cellAttr + '][' + lineAttr + ']';
        return selector;
      }
      const selectCodeLines = (annoteEl) => {
        const doc = window.document;
        const targetCell = annoteEl.getAttribute("data-target-cell");
        const targetAnnotation = annoteEl.getAttribute("data-target-annotation");
        const annoteSpan = window.document.querySelector(selectorForAnnotation(targetCell, targetAnnotation));
        const lines = annoteSpan.getAttribute("data-code-lines").split(",");
        const lineIds = lines.map((line) => {
          return targetCell + "-" + line;
        })
        let top = null;
        let height = null;
        let parent = null;
        if (lineIds.length > 0) {
            //compute the position of the single el (top and bottom and make a div)
            const el = window.document.getElementById(lineIds[0]);
            top = el.offsetTop;
            height = el.offsetHeight;
            parent = el.parentElement.parentElement;
          if (lineIds.length > 1) {
            const lastEl = window.document.getElementById(lineIds[lineIds.length - 1]);
            const bottom = lastEl.offsetTop + lastEl.offsetHeight;
            height = bottom - top;
          }
          if (top !== null && height !== null && parent !== null) {
            // cook up a div (if necessary) and position it 
            let div = window.document.getElementById("code-annotation-line-highlight");
            if (div === null) {
              div = window.document.createElement("div");
              div.setAttribute("id", "code-annotation-line-highlight");
              div.style.position = 'absolute';
              parent.appendChild(div);
            }
            div.style.top = top - 2 + "px";
            div.style.height = height + 4 + "px";
            div.style.left = 0;
            let gutterDiv = window.document.getElementById("code-annotation-line-highlight-gutter");
            if (gutterDiv === null) {
              gutterDiv = window.document.createElement("div");
              gutterDiv.setAttribute("id", "code-annotation-line-highlight-gutter");
              gutterDiv.style.position = 'absolute';
              const codeCell = window.document.getElementById(targetCell);
              const gutter = codeCell.querySelector('.code-annotation-gutter');
              gutter.appendChild(gutterDiv);
            }
            gutterDiv.style.top = top - 2 + "px";
            gutterDiv.style.height = height + 4 + "px";
          }
          selectedAnnoteEl = annoteEl;
        }
      };
      const unselectCodeLines = () => {
        const elementsIds = ["code-annotation-line-highlight", "code-annotation-line-highlight-gutter"];
        elementsIds.forEach((elId) => {
          const div = window.document.getElementById(elId);
          if (div) {
            div.remove();
          }
        });
        selectedAnnoteEl = undefined;
      };
        // Handle positioning of the toggle
    window.addEventListener(
      "resize",
      throttle(() => {
        elRect = undefined;
        if (selectedAnnoteEl) {
          selectCodeLines(selectedAnnoteEl);
        }
      }, 10)
    );
    function throttle(fn, ms) {
    let throttle = false;
    let timer;
      return (...args) => {
        if(!throttle) { // first call gets through
            fn.apply(this, args);
            throttle = true;
        } else { // all the others get throttled
            if(timer) clearTimeout(timer); // cancel #2
            timer = setTimeout(() => {
              fn.apply(this, args);
              timer = throttle = false;
            }, ms);
        }
      };
    }
      // Attach click handler to the DT
      const annoteDls = window.document.querySelectorAll('dt[data-target-cell]');
      for (const annoteDlNode of annoteDls) {
        annoteDlNode.addEventListener('click', (event) => {
          const clickedEl = event.target;
          if (clickedEl !== selectedAnnoteEl) {
            unselectCodeLines();
            const activeEl = window.document.querySelector('dt[data-target-cell].code-annotation-active');
            if (activeEl) {
              activeEl.classList.remove('code-annotation-active');
            }
            selectCodeLines(clickedEl);
            clickedEl.classList.add('code-annotation-active');
          } else {
            // Unselect the line
            unselectCodeLines();
            clickedEl.classList.remove('code-annotation-active');
          }
        });
      }
  const findCites = (el) => {
    const parentEl = el.parentElement;
    if (parentEl) {
      const cites = parentEl.dataset.cites;
      if (cites) {
        return {
          el,
          cites: cites.split(' ')
        };
      } else {
        return findCites(el.parentElement)
      }
    } else {
      return undefined;
    }
  };
  var bibliorefs = window.document.querySelectorAll('a[role="doc-biblioref"]');
  for (var i=0; i<bibliorefs.length; i++) {
    const ref = bibliorefs[i];
    const citeInfo = findCites(ref);
    if (citeInfo) {
      tippyHover(citeInfo.el, function() {
        var popup = window.document.createElement('div');
        citeInfo.cites.forEach(function(cite) {
          var citeDiv = window.document.createElement('div');
          citeDiv.classList.add('hanging-indent');
          citeDiv.classList.add('csl-entry');
          var biblioDiv = window.document.getElementById('ref-' + cite);
          if (biblioDiv) {
            citeDiv.innerHTML = biblioDiv.innerHTML;
          }
          popup.appendChild(citeDiv);
        });
        return popup.innerHTML;
      });
    }
  }
});
</script>
</div> <!-- /content -->




</body></html>