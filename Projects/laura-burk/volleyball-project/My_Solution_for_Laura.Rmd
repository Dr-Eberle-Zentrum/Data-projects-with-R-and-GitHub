---
title: "Volleyball Solution"
author: "Nicolai Schwarz"
date: "2024-01-12"
output: md_document
---

```{r setup, include=FALSE}
# get this packages
library(tidyverse)
library(countrycode)
library(dplyr)
library(stringr)
library(emo)
library(readr)
knitr::opts_chunk$set(echo = TRUE)
 rm(list = ls())
```

***

OKay let's start with the roster files.

***

```{r folder_content, echo=FALSE}
folder_path_roster <- file.path(getwd(), "team-rosters")
```

***

But we could also start with creating all folder path's in once aswell.

***

```{r all_paths, echo=TRUE}
folders <- list.files(getwd(), full.names = TRUE) %>%
  .[!grepl("\\.", .)]

#folders
```

***

To import the `csv-dats` let's recycle the `auto_import_csv`-function from my other Project Solution.
(Had to modify it a bit so we can use it for all datatyp's more easily)
-> got no glue why bus this not working for `.tsv`files and read_tsv
solved it by apply an `suffix`variable

***

```{r import_function, echo=TRUE }

auto_import <- function(file_path, datatyp, suffix = ""){
  
  file_list <- list.files(path = file_path, pattern = paste("\\.", datatyp, "$", sep = ""), full.names = TRUE)        #-> here we could change the auto import to other data type's  -> put that part in a seperate variable inside the function
  data_frames <- list()
  
  for (file in file_list) {
    df_name <- tools::file_path_sans_ext(basename(file))  # uses filename as dataframe
    
    read_call <- paste0("read_", datatyp, suffix, sep = "") # need to paste the "2" here to read (german) encodeing <- solved it with suffix
    
    data_frames[[df_name]] <- do.call(read_call, list(file, locale = locale(encoding = "cp852")))
  }
  
  return(data_frames)
}
```

***

```{r import_roster, echo=TRUE}

all_rosters <- auto_import(folders[4], datatyp="csv", "2")

#str(all_rosters, list.len = 2)
```

***

Alright, now let's start to clean the data.

To do so, let's have a closer look what's the unique values and find some Regex for.

Therefor i wrote a `get_unique_values` function to take a closer look at all the unique values.

***

```{r unique_values, echo=TRUE}

get_unique_values <- function(data, column){
  unique_values <- unique(unlist(lapply(data, function(df) df[[column]])))
  return(unique_values)
}

```

***

Now we can easily look into the column's values

***

```{r show_values, echo=TRUE}

#get_unique_values(all_rosters, "Gender")
#get_unique_values(all_rosters, "Position")
#get_unique_values(all_rosters, "Nationality")

```

***

Quiet some mistakes to correct, let's create some  `adjust_map's` for the Regex

To use the `countrycode`package proper we also should do some pre mutating for `Nationality`.

***
```{r adjust_maps, echo=TRUE}

adjust_map_position <- c("^[zZ].*|^[sS]e.*" = "setter",
                "^[mM].*" = "middle blocker",
                "^[aA]u.*|^[oO]u.*" = "outside hitter",
                "^[dD].*|^[oO]p.*" = "opposite hitter",
                "^[uU].*|^[lL].*" = "libero",
                "^[tT]r.*|^[cC]h.*|.*[hH]ead.*" = "head coach")

adjust_map_country <- c("^[dD].*|^[gG].*"= "Deutschland",
                        ".*wenia$"= "Slovenia",
                        ".*lie$"="Australien") # could shorten it with ".*ie$" ->".*ia$" (eng. Australia) prob. str_detect than

```

***

Due to `Nationality` contains two different languages, we need a function to do it (at once).

***

```{r two_language, echo=TRUE}
country_code <- function(df, language){
  df$Nationality <- countrycode(df$Nationality, origin = paste("country.name", language, sep = "."), destination = "ioc", nomatch=NULL)
  return(df)
}
```


***
```{r adjust_roster, echo=TRUE}
all_rosters_clean <- lapply(all_rosters, function(df) {
  suppressWarnings({
    df %>%
    mutate(Gender = ifelse(str_detect(Gender, "^[fF]|2"), "female", "male"),
           Position = str_replace_all(Position, adjust_map_position),
           Nationality = str_replace_all(Nationality, adjust_map_country))%>%
    filter(Position %in% adjust_map_position)%>%
    mutate(Height = as.numeric(Height)/100)%>%
    country_code(language ="de")%>%
    country_code(language ="en")%>%
    select(-(1:3))%>%
    rename("Name"="Last Name First Name")
  })
})
#str(all_rosters_clean, list.len = 3)
```

***

Alright this Part is done, lets go for the `topscorer's`files

For simply import them by the `auto_import` function we first have to mutate the `.txt`into `.tsv`format.
(Due to the logic of the function)

***

```{r txt_to_tsv, echo=TRUE, eval=FALSE}

txt_files <- list.files(path = folder_path_topscorers, pattern = "\\.txt$", full.names = TRUE)

for (file in txt_files) {
  tsv_file <- sub("\\.txt$", ".tsv", file)
  file.copy(file, tsv_file)
}
```

#### Remind:
  **Note: Erease the eval = FALSE part if you first using the code**

*** 

Now we can simply apply the `auto_import`function.

***

```{r import_topscore, echo=TRUE}
all_topscorer <- auto_import(folders[5], datatyp="tsv")
#str(all_topscores, list.len = 2)
```

***

Let's check for misstakes with our previous `get_unique_values`function.

***

```{r check_topscorer, echo=TRUE, eval=FALSE}
get_unique_values(all_topscorer_clean, "Team")
get_unique_values(all_topscorer_clean, "Position")
na_count <- sapply(all_topscorer_clean, function(df) sum(is.na(df$Position)))

na_count


```
***

As we can see there's some `NA`-values, but these shouldn't border us right now.

***

Now let's clean the Position column with our `adjust_map`, adjust column names and mutate the `errors_per_set`-column.

***

```{r adjust_topscorer, echo=TRUE}
all_topscorer_clean <- lapply(all_topscorer, function(df) {
    df %>%
    setNames(gsub(" ", "_", colnames(.)))%>% # instead of rename, replaces all "spaces" with "_",colnames(.)to backreference to df in functions
    mutate(Position = str_replace_all(Position, adjust_map_position),
           errors_per_set = (Errors_overall / Sets_played)) 
})
all_topscorer_clean[[2]] <- all_topscorer_clean[[2]] %>% # couldn't find out how to do in lapply-fct, due to not all df got "team" column "yet"
  mutate(Team = gsub("Ř", "ü", Team))

#str(all_topscorer_clean, list.len = 3)
```

***
**Note :** *Could probably go for the misstakes in Names by apply the `get_unique_values`function to both, the topscorer & roster list, store them in a list and apply the function again on it.*

**Than we could join, roster and topscorer by Name**

***

Okay let's go for the games now.

***

```{r import_games, echo=TRUE}

all_games <- auto_import(folders[2], datatyp="csv", "2")

#str(all_games, list.len = 2)
```

***

Let's have alook and clean it.

***

```{r check_games, echo=TRUE, eval=FALSE}
get_unique_values(all_games_clean, "Geschlecht")
na_count <- sapply(all_games, function(df) sum(is.na(df$Geschlecht)))

na_count


```

***

```{r adjust_games, echo=TRUE}
all_games_clean <- lapply(all_games, function(df) {
    df %>%
    setNames(gsub(" ", "_", colnames(.))) %>%
  mutate(Mannschaft_1 = gsub("Ř", "ü", Mannschaft_1),
         Mannschaft_2 = gsub("Ř", "ü", Mannschaft_2),
         Gastgeber = gsub("Ř", "ü", Gastgeber),
         Austragungsort = gsub("Ř", "ü", Austragungsort),
         Geschlecht = ifelse(str_detect(Geschlecht, "^[fF]|2"), "female", "male"))
})
  
all_games_clean
```

***

Alright,so far, so good!

Next mutating all these values requiered for the barplot.

Let's get a list of all Teams first
***
```{r all_games_teams,echo=TRUE}
all_games_teams <- get_unique_values(all_games_clean, "Mannschaft_1")
all_games_teams
```
***

now let's check how often each of them played at home and away

***

```{r home_games,echo=TRUE}
num_home_games <-lapply(all_games_teams, function(team){
  lapply(all_games_clean, function(df){
    df%>%
    filter(Mannschaft_1 == team)%>%
    nrow()
  })
})

num_away_games <-lapply(all_games_teams, function(team){
  lapply(all_games_clean, function(df){
    df%>%
    filter(Mannschaft_2 == team)%>%
    nrow()
  })
})

num_total_games <-lapply(all_games_teams, function(team){
  lapply(all_games_clean, function(df){
    df%>%
    filter(Mannschaft_1 == team|Mannschaft_2 == team)%>%
    nrow()
  })
})

```



***

This already looks like, as we can put it together.

***

```{r try}
count_team_games <- function(team, df) {
  home_games <- df %>%
    filter(Mannschaft_1 == team) %>%
    nrow()
  
  away_games <- df %>%
    filter(Mannschaft_2 == team) %>%
    nrow()
  
  total_games <- df %>%
    filter(Mannschaft_1 == team | Mannschaft_2 == team) %>%
    nrow()
  
  return(c(Home = home_games, Away = away_games, Total = total_games))
}

num_games_in_once <- lapply(all_games_teams, function(team) {
  lapply(all_games_clean, count_team_games, team = team)
})
num_games_in_once
```

***

Next go fpr win and losses

***

```{r try victory, echo=TRUE}
num_victory <-lapply(all_games_teams, function(team){
  lapply(all_games_clean, function(df){
    df%>%
    filter((Mannschaft_1 == team & Satzpunkte_1 == 3) | (Mannschaft_2 == team & Satzpunkte_2 == 3))%>%
    nrow()
  })
})

num_losses <-lapply(all_games_teams, function(team){
  lapply(all_games_clean, function(df){
    df%>%
    filter((Mannschaft_1 == team & Satzpunkte_1 != 3) | (Mannschaft_2 == team & Satzpunkte_2 != 3))%>%
    nrow()
  })
})
num_losses
```

***
For all the average stuff im not sure if it aint  more easy to combine all games into one df to get total counts more easy for each team.

Anyway we can count total of sets now ans than let's see.

***

```{r total_sets_played_per_game, echo=TRUE}

num_sets_per_game_played <-lapply(all_games_teams, function(team){
  lapply(all_games_clean, function(df){
    df%>%
    filter(Mannschaft_1 == team|Mannschaft_2 == team)%>%
    summarise(
      Sum_Satzpunkte = sum(Satzpunkte_1 + Satzpunkte_2),
      Avg_Satzpunkte = mean(Satzpunkte_1 + Satzpunkte_2)) # actually could put the whole sum function in the mean function
  })
})

```
***

**Note:** * This is the total and average number of setsplayed per game* **not** average sets to win, wait a minute.....

than it should be **right?**

Next Average points per set

***
**Dunno here why its working with backticks but aint with normal ""**

```{r avg_points_per_game, echo=TRUE}

avg_points_per_set<- lapply(all_games_teams, function(team) {
  lapply(all_games_clean, function(df) {
    df %>%
      filter(Mannschaft_1 == team | Mannschaft_2 == team) %>%
      summarise(
        Avg_Ballpunkte_first_set = mean(ifelse(Mannschaft_1 == team, `Satz_1_-_Ballpunkte_1`, `Satz_1_-_Ballpunkte_2`)),
        Avg_Ballpunkte_sec_set = mean(ifelse(Mannschaft_1 == team, `Satz_2_-_Ballpunkte_1`, `Satz_2_-_Ballpunkte_2`)),
        Avg_Ballpunkte_third_set = mean(ifelse(Mannschaft_1 == team, `Satz_3_-_Ballpunkte_1`, `Satz_3_-_Ballpunkte_2`)),
        Avg_Ballpunkte_fourth_set = mean(ifelse(Mannschaft_1 == team, `Satz_4_-_Ballpunkte_1`, `Satz_4_-_Ballpunkte_2`)),
        Avg_Ballpunkte_fifth_set = mean(ifelse(Mannschaft_1 == team, `Satz_5_-_Ballpunkte_1`, `Satz_5_-_Ballpunkte_2`))
        
      )
  })
})

avg_points_per_set
```