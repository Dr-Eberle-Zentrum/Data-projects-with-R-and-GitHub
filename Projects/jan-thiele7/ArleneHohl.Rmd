---
title: "Solution fo Jan's project"
output: md_document
date: "`r Sys.Date()`"
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```

# Solution for Jan's project

This is my current solution for Jan's project. The goal was to create a plot with eco- and nutriscore of different food groups. I have to admit that I used ChatGPT quite a lot for this project, as I didn't have too much time on hand. So if you see any ways how the code can be optimised, feel free to let me know!

## Step 1: install libraries

```{r, echo=T, results='hide',  message = F}
library("tidyverse")
```

## Step 2: load data and select variables
I used the subset Jan provided and selected the following variables: nutriscore_grade, ecoscore_grade and pnns_groups_1 and 2 (those included the different food categories). I then deleted rows containing missing data.

```{r, echo=T, results='hide', warnings = F, message = F}
data <- read_csv("data_openfood.csv", na = c("", "NA", "unknown", "not-applicable"), col_select = c("nutriscore_grade","ecoscore_grade", "pnns_groups_1", "pnns_groups_2")) %>% 
  drop_na()

```

This is how the dataset looks like:
```{r, echo = FALSE}
head(data)
```

## Step 3: Combine food categories

As the food categories were saved in two variables, I tried to combine them. Those were the different categories in pnns_groups_1:

```{r, echo = FALSE}

data %>% 
  group_by(pnns_groups_1) %>% 
  count()
```

And those were the groups in pnns_groups_2:

```{r, echo = FALSE}
data %>% 
  group_by(pnns_groups_2) %>% 
  count()
```

As you can see, the second group was way more detailed. I decided to combine the following categories and keep the other categories as they are in pnns_groups_2.

```{r}
data <- data %>%
  mutate(pnns_groups_2 = case_when(
    pnns_groups_2 %in% c("Breakfast cereals", "Cereals") ~ "Cereals",
    pnns_groups_2 %in% c("Sweets", "Biscuits and cakes", "Ice cream", "Dairy desserts", "Pastries") ~ "Sweets",
    pnns_groups_2 %in% c("Fruits", "Vegetables") ~ "Fruits and Vegetables",
    pnns_groups_2 %in% c("Fruit juices", "Fruit nectars") ~ "Fruit Juices and Nectars",
    pnns_groups_2 %in% c("Potatoes", "Bread") ~ "Starchy Foods",
    pnns_groups_2 %in% c("Meat", "Offals") ~ "Meat and Offals",
    pnns_groups_2 == "Salty and fatty products" ~ "Salty snacks",
    pnns_groups_2 == "Teas and herbal teas and coffees" ~ "Tea and coffee",
    pnns_groups_2 == "Pizza pies and quiches" ~ "Pizza",
    TRUE ~ pnns_groups_2
  ))
```

Now it looks like this:

```{r, echo = FALSE}
data %>% 
  group_by(pnns_groups_2) %>% 
  count()
```

## Step 4: Create and reshape matrix to count

Because each category in itself varied a lot in their eco- and nutriscore, I then had to create a matrix for each category, counting how often which combination of nutri- and ecoscore appeared. To do this I first extracted the categories and defined possible values of nutri- and ecoscores. I alsp created a dataframe containing all possible combinations of nutri- and ecoscores.

```{r}
categories <- unique(data$pnns_groups_2)
grades <- c('a', 'b', 'c', 'd', 'e')
combinations <- expand.grid(nutriscore_grade = grades, ecoscore_grade = grades)
```

I then grouped the counts for each foodgroup:

```{r}
grouped_counts <- data %>% 
  group_by( pnns_groups_2, nutriscore_grade, ecoscore_grade ) %>% 
  count() %>% 
  ungroup()

grouped_counts
```

Then I had to count, how often each combination appeared in each category. To do this, I created a list of dataframes with one dataframe for each category. Each dataframe contains the count of each possible combination.

```{r}
list_of_data_counts <- lapply(categories, function(cat) {
  # filter grouped data for current category and left-join it with possible combinations
  combinations %>% 
    left_join(grouped_counts %>%
                filter(pnns_groups_2 == cat), by = c("nutriscore_grade", "ecoscore_grade"))%>%
    # change NA counts to zero
    mutate(n = replace_na(n, 0), pnns_groups_2 = replace_na(pnns_groups_2, cat)) %>% 
    # delete pnns_groups_2 row
    select(-"pnns_groups_2") %>% 
    # change format of table
    pivot_wider(names_from = ecoscore_grade, 
                values_from = n, 
                values_fill = list(n = 0)) %>% 
    # change order of rows so a is at bottom
    arrange(match(nutriscore_grade, rev(grades))) %>% 
    # make it a dataframe
    as.data.frame() %>% 
  # delete first row
    select(-1)
})

names(list_of_data_counts) <- categories
```

Here is an example, how such a dataframe looks like for Sweets:

```{r, echo=FALSE}
list_of_data_counts[['Sweets']]
```

## Step 5: Calculating center of mass

Now I had to calculate the center of mass for every category.

```{r}
center_of_mass <- lapply(list_of_data_counts, function(count_matrix) {
  # sum entries in count_matrix
  num <- sum(count_matrix)
  # weighting of columns
  column_weights <- colSums(count_matrix) / num
  # reverse sequence of rows
  count_matrix <- count_matrix[rev(rownames(count_matrix)), ]
  # weighting of rows
  row_weights <- rowSums(count_matrix) / num
  # calculation of center of mass, return x and y coordinates
  c(sum(column_weights * 0:4), sum(row_weights * 0:4))
})


```

Here is how this looks for Sweets as an example:

```{r}
center_of_mass[['Sweets']]
```

## Step 6: Calculating size of bubbles

The size of bubbles was defined as the variance inside of the categories. That means that a category that differed a lot in eco- and nutriscore should have a bigger bubble size. Therefore, I first had to calculate the variances of the categories:

```{r}
variance_data <- data %>%
  # group by categories
  group_by(pnns_groups_2) %>%
  summarise(
    # calculate variance in nutriscore per category
    nutriscore_var = var(as.numeric(factor(nutriscore_grade, levels = grades)), na.rm = TRUE),
    # calculate variance in ecoscore per category
    ecoscore_var = var(as.numeric(factor(ecoscore_grade, levels = grades)), na.rm = TRUE),
    # bubbles size is sum of both variances
    bubble_size = nutriscore_var + ecoscore_var
  )

head(variance_data)
```

Then I scaled the bubbles size to 1000 based on the maximum.

```{r}
# get maximum of bubble site
max_bubble_size <- max(variance_data$bubble_size)
# scale bubble size based on max
variance_data <- variance_data %>%
  mutate(bubble_size = (bubble_size / max_bubble_size) * 1000)

head(variance_data)
```

As you can see, Cereals had the biggest variance = bubble size, so they now have a scaled bubble size of 1000.

## Step 7: combine center of mass and variance

I was not able to combine the computation of center of mass and variance in one step, as Martin had suggested. I therefore now combine the two.

```{r}

final_data <- variance_data %>%
  merge(data.frame(
  category = names(center_of_mass),
  center_x = sapply(center_of_mass, function(x) x[1]),
  center_y = sapply(center_of_mass, function(x) x[2])))%>%
  mutate(
    color_factor_x = factor(floor(center_x)),
    color_factor_y = factor(floor(center_y))
  )

head(final_data)
```

## Step 8: Plot

Now it is finally time to plot!

```{r, warnings = FALSE, message = F}
final_data %>% 
ggplot(aes(x = center_x, y = center_y)) +
  # fill = nutri, colour = eco, shape: circles
  geom_point(aes(size = bubble_size, color = color_factor_x, fill = color_factor_y, stroke = 1.5), shape = 21) +
  # no legend, set size of bubbles
  scale_size_continuous(range = c(1, 10), guide = "none") +
  scale_fill_identity() +
  # add category-label
  geom_text(aes(label = category), size = 2) +
  # add labs
  labs(x = "Ecoscore", y = "Nutriscore", title = "Relationship between Nutri- and Ecoscore") +
  # add scale
  scale_x_continuous(breaks = 0:5, labels = c('a', 'b', 'c', 'd', 'e', '')) +
  scale_y_continuous(breaks = 0:5, labels = c('a', 'b', 'c', 'd', 'e', '')) +
  coord_cartesian(xlim = c(0, 5), ylim = c(0, 5)) +
  # color them
  scale_fill_manual(
    name = "Nutriscore",
    values = c("green", "greenyellow", "yellow", "orange", "darkred"),
    labels = c('a', 'b', 'c', 'd', 'e'))+
  scale_color_manual(
    name = "Ecoscore",
    values = c("green", "greenyellow", "yellow", "orange", "darkred"),
    labels = c('a', 'b', 'c', 'd', 'e')) +
  # change design
  theme_minimal() +
  theme(
    plot.background = element_rect(fill = "#f0f0f0"),
    panel.grid.major = element_line(color = "gray", linetype = "dashed"),
    axis.line = element_line(color = "black"),
    axis.title.x = element_text(size = 16),
    axis.title.y = element_text(size = 16),
    axis.text.x = element_text(size = 12),
    axis.text.y = element_text(size = 12),
    plot.title = element_text(size = 18, hjust = 0.5)
  )
```


As you can see, the category labels are a little all over the place. But I'm quite happy how close I got to Jans plot!
