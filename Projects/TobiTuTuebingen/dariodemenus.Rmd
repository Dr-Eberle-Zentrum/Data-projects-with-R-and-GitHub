---
title: "Windkraftausbau in Baden-Württemberg"
author: "Dario Demenus"
date: "`r Sys.Date()`"
output: md_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE, warning = FALSE, message = FALSE)
library(tidyverse)
library(lubridate)
library(ggcorrplot) # Optional, helps with correlograms, but we can do it manually with ggplot too
library(viridis)    # For nice map colors
```


```{r dataimport}
# Import using readr. 
# The locale encoding argument helps ensure special characters are read correctly.
wind_data <- read_delim("WindenergieBW.csv", 
                        delim = ",", 
                        locale = locale(encoding = "UTF-8"))

# Inspect column names to ensure no BOM artifacts (like "ï..Zuständige")
colnames(wind_data)

# Data Cleaning Pipeline
clean_wind <- wind_data %>%
  # Rename columns for easier access (CamelCase or English is often easier)
  rename(
    Landkreis = `Zuständige Dienststelle`,
    Gemeinde = Standortgemeinde,
    Leistung_MW = `Generatorleistung [MW]`,
    Nabenhoehe_m = `Nabenhöhe [m]`,
    Rotor_m = `Rotordurchmesser [m]`,
    Inbetriebnahme = Inbetriebnahmedatum
  ) %>%
  # Convert Date from character (German format dd.mm.yyyy) to Date object
  mutate(Inbetriebnahme = dmy(Inbetriebnahme)) %>%
  mutate(Jahr = year(Inbetriebnahme)) %>%
  # Filter out rows that might have missing coordinates if necessary for the map
  filter(!is.na(Ost), !is.na(Nord))

# Preview
head(clean_wind)
```

```{r yearly_wind_capacity}
# 1. Define a scaling factor
scale_factor <- 3 
# Das Ziel: 1,2 GW = 1200 MW
ziel_mw <- 1200

# 2. Aggregating
yearly_stats <- clean_wind %>%
  group_by(Jahr) %>%
  summarise(
    New_Turbines = n(),
    Total_Power = sum(Leistung_MW, na.rm = TRUE)
  )

# 3. Plotting
ggplot(yearly_stats, aes(x = Jahr)) +
  # Primary Data (Bars): The number of turbines
  geom_bar(aes(y = New_Turbines), stat = "identity", fill = "steelblue", alpha = 0.7) +
  
  # Secondary Data (Line): Actual Power
  geom_line(aes(y = Total_Power / scale_factor), color = "red", linewidth = 1) + 
  
  # --- NEU: Horizontale Linie für das Ausbauziel ---
  # Wir müssen 1200 MW durch den scale_factor teilen, damit es im Graphen an der richtigen Stelle liegt
  geom_hline(yintercept = ziel_mw / scale_factor, color = "darkgreen", linetype = "dashed", linewidth = 1) +
  
  # Optional: Beschriftung für die Linie direkt im Plot
  annotate("text", x = min(yearly_stats$Jahr), y = (ziel_mw / scale_factor) + 5, 
           label = "Ziel: 1,2 GW/Jahr", color = "darkgreen", hjust = 0, vjust = 0, fontface = "bold") +
  
  # Axis Configuration
  scale_y_continuous(
    name = "Anzahl neue Windräder",
    # We multiply the labels back by the scale_factor so the numbers are correct
    sec.axis = sec_axis(~ . * scale_factor, name = "Neu installierte Leistung [MW]")
  ) +
  
  theme_minimal() +
  labs(
    title = "Windkraftausbau in Baden-Württemberg",
    subtitle = "Vergleich von Anzahl, Leistung und politischem Ziel (1,2 GW)",
    caption = "Datenquelle: LUBW"
  )
```
```{r correlogram_manual_triangle}
# 1. Daten vorbereiten
# (Ich gehe davon aus, dass 'clean_wind' bereits geladen ist)
corr_data <- clean_wind %>%
  select(Leistung_MW, Nabenhoehe_m, Rotor_m) %>%
  drop_na()

# 2. Berechnungen
cor_matrix <- cor(corr_data)
p_matrix <- cor_pmat(corr_data) # Benötigt library(ggcorrplot) oder rstatix

# Daten ins Long-Format bringen
# A: Korrelationen
df_cor <- cor_matrix %>%
  as.data.frame() %>%
  rownames_to_column("Var1") %>%
  pivot_longer(-Var1, names_to = "Var2", values_to = "rho")

# B: P-Werte
df_p <- p_matrix %>%
  as.data.frame() %>%
  rownames_to_column("Var1") %>%
  pivot_longer(-Var1, names_to = "Var2", values_to = "p_val")

# C: Zusammenfügen
plot_data <- df_cor %>%
  left_join(df_p, by = c("Var1", "Var2"))

# 3. Das untere Dreieck herausfiltern
plot_data <- plot_data %>%
  mutate(Var1 = factor(Var1, levels = colnames(cor_matrix)),
         Var2 = factor(Var2, levels = colnames(cor_matrix))) %>%
  filter(as.numeric(Var1) > as.numeric(Var2))

# --- DEFINITION DER LABELS ---
# Hier legen wir fest, welcher technische Name wie angezeigt werden soll
my_labels <- c(
  "Leistung_MW"  = "Leistung in Megawatt",
  "Nabenhoehe_m" = "Nabenhöhe in Meter",
  "Rotor_m"      = "Rotor in Meter"
)

# 4. Plotten
ggplot(plot_data, aes(x = Var1, y = Var2, fill = rho)) +
  
  # A. Die Kacheln
  geom_tile(color = "white") +
  
  # B. Die Zahlen
  geom_text(aes(label = round(rho, 2)), color = "black", size = 4, nudge_x = -0.15) +
  
  # C. Die Kreuze (bei Signifikanz)
  geom_point(data = filter(plot_data, p_val <= 0.05), 
             shape = 4, size = 4, stroke = 1, nudge_x = 0.15) +
  
  # D. Farben
  scale_fill_gradient2(low = "blue", high = "red", mid = "white", 
                       midpoint = 0, limit = c(-1,1), name = "Corr") +
  
  # E. ACHSENBESCHRIFTUNG ANPASSEN (NEU)
  scale_x_discrete(labels = my_labels) +
  scale_y_discrete(labels = my_labels) +
  
  # F. Design
  theme_minimal() +
  coord_fixed() +
  labs(title = "Korrelogramm",
       subtitle = "Zahl = Korrelation | Kreuz = Signifikant (p < 0.05)",
       x = "", y = "") +
  theme(panel.grid = element_blank())
```

```{r landkreis_aggregation}
# Preparation: Aggregating per Landkreis (as per project description)
# We aggregate to find the 'center' of wind power for each district
landkreis_agg <- clean_wind %>%
  group_by(Landkreis) %>%
  summarise(
    Turbine_Count = n(),
    Mean_Ost = mean(Ost, na.rm = TRUE),
    Mean_Nord = mean(Nord, na.rm = TRUE),
    # Using Power sum
    Sum_Leistung = sum(Leistung_MW, na.rm = TRUE) 
  )

head(landkreis_agg)
# Plotting the Map
# We use the raw coordinate data (clean_wind) but color the hexagons 
# based on the sum of Power (z) in that area.

ggplot(clean_wind, aes(x = Ost, y = Nord, z = Leistung_MW)) +
  # stat_summary_hex bins the data and applies a function (sum) to the z variable
  stat_summary_hex(fun = sum, bins = 20) +
  scale_fill_viridis_c(option = "C", name = "Summe Leistung\n(MW)") +
  theme_void() + # Clean map theme
  coord_fixed() +
  labs(title = "Räumliche Verteilung der Windkraftleistung",
       subtitle = "Hexbin Map (Summierte Leistung pro Kachel)")
```
```{r landkreis_aggregation_map}
# 1. Benötigte Pakete laden
library(sf)
library(giscoR)
library(tidyverse)

# 2. Geodaten für BW laden (NUTS 3 Ebene = Landkreise)
# Wir laden die offiziellen Verwaltungsgrenzen
bw_kreise <- gisco_get_nuts(country = "Germany", nuts_level = 3, resolution = "03") %>%
  filter(startsWith(NUTS_ID, "DE1")) %>% # Nur Baden-Württemberg
  st_transform(25832) # Transformation in ETRS89 / UTM Zone 32N (passend zu Ihren Daten)

# 3. Winddaten in ein räumliches Format (sf) umwandeln
# Wir machen aus der Tabelle eine Karte mit Punkten
wind_points <- clean_wind %>%
  # Zeilen ohne Koordinaten entfernen
  filter(!is.na(Ost), !is.na(Nord)) %>% 
  # Umwandlung in sf-Objekt mit dem Koordinatensystem Ihrer Daten (EPSG: 25832)
  st_as_sf(coords = c("Ost", "Nord"), crs = 25832)

# 4. Räumlicher Join (Spatial Join)
# Wir "kleben" an jedes Windrad die Infos des Landkreises, in dem es steht
wind_in_kreise <- st_join(wind_points, bw_kreise)

# 5. Aggregation pro Landkreis
# Jetzt summieren wir die Leistung basierend auf den Geodaten-IDs
map_data <- bw_kreise %>%
  left_join(
    wind_in_kreise %>%
      st_drop_geometry() %>% # Geometrie kurz weglassen für schnelleres Rechnen
      group_by(NUTS_ID) %>%
      summarise(
        Anzahl_Windraeder = n(),
        Sum_Leistung = sum(Leistung_MW, na.rm = TRUE)
      ),
    by = "NUTS_ID"
  )

# 6. Karte Plotten
ggplot(map_data) +
  # Die Landkreise zeichnen, Füllfarbe nach Leistung
  geom_sf(aes(fill = Sum_Leistung), color = "white", size = 0.2) +
  
  # Farbskala anpassen (Viridis "C" = Plasma ist oft gut für Heatmaps)
  scale_fill_viridis_c(
    option = "C", 
    name = "Installierte\nLeistung (MW)",
    na.value = "grey90", # Landkreise ohne Windkraft grau färben
    direction = 1
  ) +
  
  # Design
  theme_void() + # Leeres Design (keine Achsen)
  labs(
    title = "Windkraftleistung pro Landkreis in BW",
    subtitle = "Choropleth-Karte basierend auf Verwaltungs-Grenzen (NUTS 3)",
    caption = "Datenquelle: LUBW | Geodaten: Eurostat/giscoR"
  ) +
  
  # Optional: Koordinatensystem festzurren (passiert bei geom_sf meist automatisch)
  coord_sf(datum = NA)

```

Das Konzept für den Proxy
Wir gewichten die MW-Leistung anhand des Alters der Anlage, um die finanziellen Phasen eines Windparks abzubilden:

Phase 1: "Neuanlagen" (0–4 Jahre):

Situation: Hohe Abschreibungen (drücken Gewinn & Gewerbesteuer), aber oft Einnahmen aus der §6 EEG-Kommunalabgabe (0,2 Cent/kWh), die sofort fließt.

Gewicht: 0.8 (Gute Einnahmen, aber noch keine volle Gewerbesteuer).

Phase 2: "Abschreibungsphase" (5–12 Jahre):

Situation: Die "Durststrecke". Hohe steuerliche Abschreibungen, Zinszahlungen an Banken. Oft zahlt der Betreiber hier kaum Gewerbesteuer an die Kommune.

Gewicht: 0.3 (Niedrigste Einnahmen für den Landkreis).

Phase 3: "Cash Cow" (> 12 Jahre):

Situation: Anlage ist oft abgeschrieben, Kredite bedient. Der Stromerlös ist fast reiner Gewinn = maximale Gewerbesteuer.

Gewicht: 1.0 (Volles Steuerpotenzial).

```{r steuer_proxy_berechnung}
# Bibliotheken laden (falls noch nicht geschehen)
library(tidyverse)
library(lubridate)

# 1. BERECHNUNG DES STEUER-PROXY
# Wir gehen davon aus, dass 'clean_wind' bereits existiert (aus Ihrem Snippet)
tax_analysis <- clean_wind %>%
  # Nur Anlagen, die wirklich Geld verdienen (keine genehmigten/stillgelegten)
  filter(Status == "in Betrieb") %>%
  
  # Alter berechnen (Bezugsjahr 2025)
  mutate(Alter = 2025 - Jahr) %>%
  
  # Die Gewichtungs-Logik anwenden
  mutate(Gewichtungsfaktor = case_when(
    Alter < 5 ~ 0.8,   # Neue Anlagen: EEG-Abgabe fließt, Gewerbesteuer niedrig
    Alter >= 5 & Alter <= 12 ~ 0.3, # Abschreibungsphase: Kaum Einnahmen
    Alter > 12 ~ 1.0,  # Cash-Cows: Anlage abgeschrieben, volle Gewerbesteuer
    TRUE ~ 0 # Fallback
  )) %>%
  
  # Den Proxy-Wert berechnen: Leistung * Faktor
  mutate(Steuerkraft_Index = Leistung_MW * Gewichtungsfaktor)

# 2. AGGREGATION NACH LANDKREIS
landkreis_ranking <- tax_analysis %>%
  group_by(Landkreis) %>%
  summarise(
    Anzahl_Windraeder = n(),
    Installierte_Leistung_MW = sum(Leistung_MW, na.rm = TRUE),
    # Der gewichtete Index ist unser Proxy für das Steueraufkommen
    Steuerkraft_Proxy = sum(Steuerkraft_Index, na.rm = TRUE)
  ) %>%
  mutate(Landkreis = str_remove(Landkreis, "Landratsamt ")) %>%
  arrange(desc(Steuerkraft_Proxy)) # Sortieren nach unserem Index

# 3. ERGEBNIS ANZEIGEN (Top 10)
print(head(landkreis_ranking, 10))

# 4. VISUALISIERUNG
# Ein schöner Plot für die Hausarbeit/Präsentation
ggplot(head(landkreis_ranking, 15), aes(x = reorder(Landkreis, Steuerkraft_Proxy), y = Steuerkraft_Proxy)) +
  geom_col(fill = "steelblue") +
  coord_flip() + # Balken horizontal für bessere Lesbarkeit der Namen
  labs(
    title = "Geschätztes Steuerpotenzial durch Windkraft (Top 15 BW)",
    subtitle = "Basierend auf installierter Leistung gewichtet nach Anlagenalter",
    x = "Landkreis",
    y = "Steuerkraft-Index (Gewichtete MW)"
  ) +
  theme_minimal()
```

```{r steuer_proxy_map}
# Wir nutzen den Dataframe 'tax_analysis' aus dem vorherigen Schritt,
# da dieser die berechnete Spalte 'Steuerkraft_Index' enthält.

ggplot(tax_analysis, aes(x = Ost, y = Nord, z = Steuerkraft_Index)) +
  # Wir summieren den Steuer-Index pro Hexagon
  stat_summary_hex(fun = sum, bins = 20) +
  # Anderes Farbschema (z.B. "D" oder "A") hilft oft, 
  # um es visuell von der reinen Leistungskarte zu unterscheiden
  scale_fill_viridis_c(option = "A", direction = -1, name = "Steuerkraft-Index\n(Gewichtete MW)") +
  theme_void() + 
  coord_fixed() +
  labs(
    title = "Räumliche Verteilung des Steuerpotenzials (Proxy)",
    subtitle = "Hexbin Map: Installierte Leistung gewichtet nach Anlagenalter (Abschreibung)"
  )
```

```{r steuer_proxy_map_mit_grenzen}
# 1. Notwendige Pakete installieren und laden
if(!require("sf")) install.packages("sf")
if(!require("giscoR")) install.packages("giscoR") # Amtliche EU-Grenzen

library(sf)
library(giscoR)

# 2. Geodaten für BW laden (NUTS-Code für BW ist "DE1")
# NUTS 1 = Bundesland, NUTS 3 = Landkreise
bw_border <- gisco_get_nuts(nuts_id = "DE1", resolution = "01") # Hohe Auflösung
bw_kreise <- gisco_get_nuts(country = "Germany", nuts_level = 3, resolution = "03") %>%
  filter(startsWith(NUTS_ID, "DE1")) # Nur Kreise in BW filtern

# 3. KOORDINATENTRANSFORMATION (Der Geographen-Schritt)
# Ihre Daten (Ost/Nord ~ 500.000 / 5.400.000) sind ETRS89 / UTM Zone 32N (Code 25832).
# Wir müssen die Grenzen in dieses System umrechnen ("projizieren").
bw_border_utm <- st_transform(bw_border, crs = 25832)
bw_kreise_utm <- st_transform(bw_kreise, crs = 25832)

# 4. Der Plot mit Grenzen
ggplot(tax_analysis, aes(x = Ost, y = Nord, z = Steuerkraft_Index)) +
  
  # A) Ebene Landkreise (Optional: dünne graue Linien zur Orientierung)
  geom_sf(data = bw_kreise_utm, 
          fill = NA, 
          color = "grey80", 
          size = 0.3, 
          inherit.aes = FALSE) + # WICHTIG: inherit.aes = FALSE, sonst sucht er x/y im shapefile
  
  # B) Ebene Landesgrenze (Dickerer schwarzer Umriss)
  geom_sf(data = bw_border_utm, 
          fill = NA, 
          color = "black", 
          size = 0.8, 
          inherit.aes = FALSE) +
  
  # C) Ihre Hexbins (wie gehabt)
  stat_summary_hex(fun = sum, bins = 25, alpha = 0.9) + # alpha macht sie leicht transparent
  
  # Styling
  scale_fill_viridis_c(option = "A", direction = -1, name = "Steuerkraft-Proxy") +
  theme_void() + 
  coord_sf(datum = NA) + # Entfernt das Koordinatengitter, behält aber die Projektion bei
  labs(
    title = "Räumliche Verteilung des Steuerpotenzials",
    subtitle = "Hexbin Map inkl. Verwaltungs-Grenzen (EPSG: 25832)"
  )
```